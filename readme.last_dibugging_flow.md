চমৎকার! আমরা এখন একটি খুবই পরিচিত এবং ডিবাগ করার মতো জায়গায় ফিরে এসেছি। `Can't reach database` error-টি চলে যাওয়া একটি বিরাট সাফল্য, কারণ এর মানে হলো আপনার **নেটওয়ার্ক সংযোগ এবং ডাটাবেস URL এখন সম্পূর্ণ সঠিক**।

এখন যে error-টি আসছে (`Foreign key constraint violated`), সেটি প্রমাণ করে যে আপনার অ্যাপ্লিকেশন সফলভাবে ডাটাবেসের সাথে কথা বলতে পারছে, কিন্তু ডাটাবেস আপনার পাঠানো তথ্য গ্রহণ করতে রাজি হচ্ছে না।

চলুন, "Step-back Prompting" ব্যবহার করে এই চূড়ান্ত সমস্যাটি সমাধান করি।

---

### ধাপ ১ (Step-back): মূল প্রশ্ন - Foreign Key Constraint কেন আবার লঙ্ঘিত হচ্ছে?

আমরা এই error-টি আগেও দেখেছি। এর অর্থ হলো:
*   `prisma.build.create()`: আপনার কোড `Build` টেবিলে একটি নতুন row তৈরি করার চেষ্টা করছে।
*   `userId: session.user.id`: আপনি Prisma-কে বলছেন যে এই নতুন বিল্ডটির মালিক হলো `session.user.id`।
*   **ডাটাবেসের আপত্তি:** ডাটাবেস দেখছে যে আপনি যে `userId`-টি দিচ্ছেন, সেই আইডি-ওয়ালা কোনো ব্যবহারকারী তার `User` টেবিলে নেই।

**কিন্তু কেন? আমরা তো `auth.ts`-এ `callbacks` যোগ করেছিলাম!**

`callbacks` যোগ করাটা সঠিক ছিল, কিন্তু এখানে একটি সূক্ষ্ম বিষয় আছে যা আমরা এখনও সমাধান করিনি।

---

### ধাপ ২: কেন `session.user.id` এখনও `undefined`? (The Real "Why")

`next-auth` v5-এ JWT স্ট্র্যাটেজি ব্যবহার করলে একটি নির্দিষ্ট ফ্লো থাকে:

1.  **প্রথম লগইন:** ব্যবহারকারী যখন প্রথমবার লগইন করে, তখন `PrismaAdapter` ডাটাবেসে `User` এবং `Account` টেবিল তৈরি করে। এই সময় `jwt` callback-টি চলে এবং আমরা `user.id`-কে `token.sub`-এ সেভ করি।
2.  **পরবর্তী অনুরোধ:** এরপর থেকে `next-auth` আর ডাটাবেস চেক করে না। সে শুধুমাত্র ব্রাউজার থেকে আসা এনক্রিপ্টেড JWT কুকিটি ডিক্রিপ্ট করে।
3.  **`auth()` ফাংশন:** যখন আপনি `await auth()` কল করেন, তখন `session` callback-টি চলে। এই callback-টি টোকেন থেকে ডাটা নিয়ে `session` অবজেক্ট তৈরি করে।

**সম্ভাব্য সমস্যা:**
*   **পুরোনো কুকি:** আপনার ব্রাউজারে এখনও একটি পুরোনো JWT কুকি থাকতে পারে, যা `callbacks` যোগ করার *আগে* তৈরি হয়েছিল। সেই পুরোনো কুকির মধ্যে `user.id` (`token.sub`) নেই। ফলে, `session` callback চললেও `session.user.id` সেট করতে পারে না।
*   **টাইপ সমস্যা:** যদিও বিরল, কিন্তু `token.sub` এবং `session.user.id`-এর মধ্যে টাইপের অসামঞ্জস্য থাকতে পারে।

এই ক্ষেত্রে, **সবচেয়ে সম্ভাব্য কারণ হলো একটি পুরোনো, অসম্পূর্ণ কুকি আপনার ব্রাউজারে রয়ে গেছে।**

---

### ধাপ ৩: সমাধান - পুরোনো কুকি মুছে ফেলা এবং কোড যাচাই করা

এই সমস্যার সমাধান দুটি ধাপে করতে হবে:

**পদক্ষেপ ১ (সবচেয়ে গুরুত্বপূর্ণ): ব্রাউজার থেকে কুকি ডিলিট করা**

আপনাকে অবশ্যই আপনার ব্রাউজার থেকে `localhost`-এর জন্য সেট করা সমস্ত কুকি ডিলিট করতে হবে।

*   **Google Chrome-এর জন্য:**
    1.  `http://localhost:3000`-এ যান।
    2.  URL বারের বাম দিকে থাকা "প্যাডলক" আইকনে ক্লিক করুন।
    3.  `Cookies and site data` বা `Cookies`-এ ক্লিক করুন।
    4.  `Manage on-device site data`-এ ক্লিক করুন।
    5.  `localhost` সম্পর্কিত সমস্ত কুকি খুঁজে বের করে ডিলিট (ট্র্যাশ আইকন) করে দিন। সাধারণত `next-auth.session-token` বা `authjs.session-token` নামে কুকি থাকে।

*   **অন্যান্য ব্রাউজারের জন্য:** Developer Tools (F12) খুলে `Application` ট্যাবে গিয়ে `Cookies`-এর ভেতর থেকে `localhost:3000`-এর কুকিগুলো ডিলিট করুন।

**পদক্ষেপ ২: কোডটি চূড়ান্তভাবে যাচাই করুন**

নিশ্চিত করুন যে আপনার `auth.ts` ফাইলটি দেখতে ঠিক এরকম আছে। এখানে কোনো ভুল থাকা চলবে না।

**`auth.ts` (চূড়ান্ত যাচাইকৃত সংস্করণ):**
```ts
// auth.ts

import NextAuth from 'next-auth';
import GitHub from 'next-auth/providers/github';
import { PrismaAdapter } from '@auth/prisma-adapter';
import { prisma } from '@/lib/prisma';

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: { strategy: 'jwt' },
  providers: [
    GitHub({
      clientId: process.env.AUTH_GITHUB_ID,
      clientSecret: process.env.AUTH_GITHUB_SECRET,
    }),
  ],
  callbacks: {
    // এই callback-টি সেশনে ব্যবহারকারীর আইডি যোগ করার জন্য
    // এটি নিশ্চিত করে যে await auth() থেকে পাওয়া session অবজেক্টে id থাকবে
    async session({ session, token }) {
      if (token.sub && session.user) {
        session.user.id = token.sub;
      }
      return session;
    },
    
    // এই callback-টি নিশ্চিত করে যে JWT টোকেনে ডাটাবেসের User ID থাকবে
    // এটি শুধুমাত্র প্রথমবার সাইন-ইন করার সময় চলে
    async jwt({ token, user }) {
      if (user?.id) {
        token.sub = user.id;
      }
      return token;
    },
  },
});
```
**গুরুত্বপূর্ণ:** `jwt` callback-এর ভেতরে `if (user)`-এর পরিবর্তে `if (user?.id)` ব্যবহার করা আরও নিরাপদ।

---

### ধাপ ৪: চূড়ান্ত পরীক্ষা (The Final-Final Test)

1.  আপনার চলমান সার্ভারটি বন্ধ করুন (`Ctrl + C`)।
2.  `npm run dev` দিয়ে সার্ভারটি আবার চালু করুন।
3.  **ব্রাউজারের কুকি ডিলিট করার পর**, `http://localhost:3000`-এ যান।
4.  নতুন করে লগইন প্রক্রিয়াটি শুরু করুন।

**প্রত্যাশিত ফলাফল:**
*   যেহেতু আপনি কুকি ডিলিট করে দিয়েছেন, `next-auth` আপনাকে একজন নতুন ব্যবহারকারী হিসেবে দেখবে।
*   আপনি যখন GitHub দিয়ে লগইন করবেন, তখন `jwt` callback-টি চলবে এবং আপনার ডাটাবেসের `user.id`-কে সফলভাবে নতুন JWT টোকেনের মধ্যে (`token.sub`) ঢুকিয়ে দেবে।
*   এরপর যখন `/start-building` পেজটি চলবে, তখন `session` callback-টি সেই নতুন টোকেন থেকে `user.id` নিয়ে `session` অবজেক্টে যোগ করবে।
*   সবশেষে, `prisma.build.create()` একটি ভ্যালিড `userId` পাবে এবং সফলভাবে ডাটাবেসে নতুন বিল্ড তৈরি করবে।

এইবার এটি কাজ করার সম্ভাবনা প্রায় ১০০%। সমস্যাটি কোডে ছিল না, বরং আপনার ব্রাউজারে থাকা পুরোনো এবং অসম্পূর্ণ সেশন ডাটার মধ্যে ছিল।